后端增删改查直接生成



前端接口调用使用 oneapi 插件自动生成

如果要前端自动生成，需要将后端的遵循openapi规范的json文档



**API签名认证**

本质：



签发签名

使用签名（校验签名）

为什么需要



保证安全性，不能随便一个人就可以调用



怎么实现

accessKey 调用的标识（复杂，无序，无规律）

secretKey 密钥 （复杂，无序，无规律）

类似用户名和密码，区别：accessKey、secretKey是无状态的



千万不能把密钥直接在服务器间进行传递，有可能被拦截



加密看第二点

2、加密

1、加密方式

将accessKey、secretKey放在Header里明文传递安全吗

答案是否定的，因为我们的请求可能被人拦截，而我们把密码放进请求头里面，可能会被别人获取



一般是根据密钥，生成签名sign



加密方式：

​ 对称加密

​ 非对称加密

​ md5 签名（不可解密）



签名的做法：



假如 ，我们有用户参数，我们用密钥与他拼接，用签名算法得到一个不可解密的值



​ 用户参数 + 密钥 => 签名生成算法（MD5,HMac,Sha1) => 不可解密的值



例子： xuan + abc => 7e7b9583aa0bc3e834fe8bcaebda38b5（这里是我随便输的，得到的值是随机的）



怎么知道签名对不对？

服务端用一模一样的参数和算法去生成签名，只要和用户传的一致，就表示密钥一致



怎么防重放？

加nonce随机数 只能用一次

但是服务端要保存用过的随机数，增加了成本

可以加timestamp 时间戳，校验它的有效期



综上所属

传递的参数

accessKey

sign （由accessKey(或者使用用户请求参数body等)、secretKey加密而来）

nonce随机数

timestamp

body（用户请求参数 可要可不要）

**API签名认证是一个很灵活的设计，具体要有哪些参数，尽量服务端调用，参数名如何要根据场景来。**



思考：难道开发者每次调用接口都要自己写签名算法？

**开发一个简单易用的SDK（starter）简历加分项**

理想情况：开发者只需要关心调用哪些接口、传递哪些参数。就跟调用自己写的代码一样简单。

 	开发starter的好处：开发者引入之后，可以直接在application.yml中写配置，自动创建客户端



spring-boot-configuration-processor的作用是自动生成配置的代码提示



接口发布/下线

这个功能首先是仅管理员使用的



发布接口

校验该接口是否存在

判断接口是否可以被调用

修改数据库接口字段为1



下线接口

校验该接口是否存在

修改数据库接口字段为 0



**权限控制**

这里添加权限校验，这里用到\*\*@AuthCheck(mustRole = “admin”)\*\*的切面注解，对应的实现方法在aop/AuthInterceptor，确保只有管理员可以上下线接口



接口调用次数统计

用户每次调用接口成功，次数+1（service)

编写方法：在service层的UserInterfaceInfoService编写方法

这里只是过流程，实际应该多校验

 	@Override

 	public boolean invokeInterfaceCount(long userId, long interfaceInfoId) {

 		if (userId <= 0 || interfaceInfoId <= 0) {

 			throw new BusinessException(ErrorCode.NOT\_FOUND\_ERROR);

 		}



 		LambdaUpdateWrapper<UserInterfaceInfo> updateWrapper = new LambdaUpdateWrapper<>();

 		updateWrapper.eq(UserInterfaceInfo::getUserId, userId)

 				.eq(UserInterfaceInfo::getInterfaceInfoId, interfaceInfoId)

 				.gt(UserInterfaceInfo::getLeftNum, 0)

 				.setSql("left\_num = left\_num -1, total\_num = total\_num + 1");



 		return update(updateWrapper);

 	}

**注意：其实这里应该添加事务，添加锁**



**4、问题**

如果每个接口的方法都写调用次数+1，是不是比较麻烦？

**致命问题：接口开发者需要自己去添加统计代码**

**就想到可以使用AOP(动态织入增强逻辑)、servlet拦截器、网关**

AOP切面的优点：独立于接口，在每个接口调用后统计次数+1

AOP切面的缺点：只存在于单个项目中，如果每个团队都要开发自己的模拟接口，那么都要写一个切面

所以最终我们在这个项目选择使用网关



**1、网关作用**



1.路由

2.负载均衡

3.统一鉴权

4.统一处理跨域

5.统一业务处理（缓存）

6.访问控制

7.发布控制

8.流量染色

9.统一接口保护

 	限制请求

 	信息脱敏

 	降级（熔断）

 	限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler

 	超时时间

 	重试（业务保护）

10.统一日志

11.统一文档



**2、具体作用**

**路由**

起到转发的作用，比如有接口A和接口B,网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器/集群）

用户a调用接口A

/a => 接口A

/b => 接口B

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories



**负载均衡**

在路由的基础上可以转发到某一个服务器

/c => 服务A/ 集群A（随机转发到其中的某一个机器）

uri从固定地址改成b:xx



**统一鉴权**

判断用户是否有权限进行操作，无论访问什么接口，我都统一去判断权限，不用重复写



**统一处理跨域**

网关统一处理跨域，不用在每个项目单独处理

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#cors-configuration



**统一业务处理**

把每个项目中都要做的通用逻辑放到上层（网关），统一处理，比如本项目的次数统计



**访问控制**

黑白名单，比如限制DDOS IP



**发布控制**

灰度发布，比如上线新接口，先给新接口分配 20%流量，老接口80% ,再慢慢调整比例

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-weight-route-predicate-factory



**流量染色**

区分用户来源

给请求（流量）添加一些标识，一般是设置请求头中，添加新的请求头

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory



**全局染色**：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#default-filters



**接口保护**

限制请求https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#requestheadersiz-gatewayfilter-factory

信息脱敏https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-removerequestheader-gatewayfilter-factory

降级（熔断） 进行兜底https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers

限流https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory

超时时间 超时就中断https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#http-timeouts-configuration

重试（业务保护）：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-retry-gatewayfilter-factory



**统一日志**

统一的请求，响应信息记录



**统一文档**

将下游项目的文档进行聚合，在一个页面统一查看

建议用：https://doc.xiaominfo.com/docs/middleware-sources/aggregation-introduction



**网关的分类**

\*\*全局网关（接入层网关）\*\*作用是负载均衡、请求日志等，不和业务逻辑绑定

\*\*业务网关（微服务网关）\*\*会有一些业务逻辑，作用是将请求转发到不同的业务/项目/接口/服务

参考文章：https://blog.csdn.net/qq\_21040559/article/details/122961395



**实现**

Nginx （全局网关），Kong网关（API网关）， 编程成本相对较高

Spring Cloud Gateway（取代了Zuul）性能高 可以用java代码来写逻辑 适于学习

网关技术选型：https://zhuanlan.zhihu.com/p/500587132



**Spring Cloud Gateway用法**

**1、核心概念**

**1、Glossary**

**官方文档如下**



Route: The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true.

Predicate: This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.

Filter: These are instances of GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.

**route路由（根据什么条件，转发到哪里）**



**predicate断言（一组规则，条件，用来确定如何转发路由）**



**filter过滤器：对请求进行一系列的处理，比如添加请求头，添加请求参数**



**2、请求流程**

 	1.客户端发起请求

 	2.Handler Mapping ：根据断言，去将请求转发到对应的路由

 	3.Web Handler：处理请求（一层层经过过滤器）

 	4.实际调用服务



**两种配置方式：**

1.配置式 （方便，规范）能用就用：

spring:

  cloud:

    gateway:

      routes:

      - id: after\_route

        uri: https://example.org

        predicates:

        - Cookie=mycookie,mycookievalue

2.编程式 （灵活，相对麻烦）：



**路由的各种断言**

官网地址:https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories

目录：

After 在xx时间之后

Before 在xx时间之前

Between 在xx时间之间

请求类别

请求头（包含Cookie)

查涧参数

客户端地址

权重：根据你设置的权重，给你把同一个访问的地址，重定到不同的服务，轻松实现发布控制



**过滤器：**

基本功能：对请求头、请求参数、响应头的增删改查

1.添加清求头：增加请求头 （可以用作流量染色）The AddRequestHeader GatewayFilter Factory

2.添加请求参数：The AddRequestParameter GatewayFilter Factory增加请求参数

3.添加响应头：The AddResponseHeader GatewayFilter Factory添加响应头

4.降级：当前网址报错，降到另一个位置

5.限流：一般会使用redis+令牌桶算法

6.重试

7.重复：The DedupeResponseHeader GatewayFilter Factory如果响应头中有重复的，去重



其他配置：

1、全局过滤器

Global Filters

定义过滤器

@Bean

public GlobalFilter customFilter() {

    return new CustomGlobalFilter();

}

public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override

    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        log.info("custom global filter");

        return chain.filter(exchange);

    }

    @Override

    public int getOrder() {

        return -1;

    }

}



2、Http timeouts configuration

Global timeouts

配置http超时

spring:

  cloud:

    gateway:

      httpclient:

        connect-timeout: 1000

        response-timeout: 5s





3、CORS Configuration

跨域配置

spring:

  cloud:

    gateway:

      globalcors:

        cors-configurations:

          '\[/\*\*]':

            allowedOrigins: "https://docs.spring.io"

            allowedMethods:

            - GET



**项目整合网关**

1.实现统一的用户鉴权 ，统一的接口调用次数统计（把API网关用到项目中）

2.完善功能

**会用到的特性**

1.路由（转发请求到模拟接口项目）

//2.负载均衡（需要用到注册中心）

3.统一鉴权(accessKey，secretKey)

4.统一处理跨域

5.统一业务处理（每次请求接口后，接口调用次数+1）

6.访问控制（黑白名单）

//7.发布控制

8.流量染色(记录请求是否为网关来的)

9.统一接口保护

 	a.限制请求

 	b,信息脱敏

 	c.降级（熔断）

 	d.限流 学习令牌桶算法，学习露桶算法，学习一下RedislimitHandler

 	e.超时时间

重试（业务保护）

统一日志(记录每次的请求和响应)

//统一文档



**业务逻辑**

1.用户发送请求到API网关

2\. 请求日志

参考之前的AOP的写法，从exchange这个路由交换机里面拿到我们所有的请求的信息

3.黑白名单

建议用白名单，更安全些

如果这个来源地址不是白名单里面的，我们就直接设个状态码（这里设置403），然后拦截掉 response.setComplete() 可以理解为设置响应完成

4.用户鉴权（(判断ak，sk是否合法）

我们可以从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数） 因为网关项目没引入MyBatis等操作数据库的类库，如果该孩操作较为复杂，可以由backend增删改查项目提供接口，我们直接调用，不用再重复写逻辑了。

 	HTTP请求（用HTTPClient、.用RestTemplate、Feign)

 	RPC(Dubbo)



异步返回问题

又出现一个问题，我们的接口调用，是在过滤器完成之后进行的，是个异步操作

image-20230202163045626

预期是等模拟接口调用完成，才记录响应日志、统计调用次数。

但现实是 chain.fitter 方法立刻返回了，直到 filter 过滤器 return 后才调用了模拟接口。

原因是：chain.filter 是个异步操作，理解为前端的 promise

解決方案：利用response 装饰者，增强原有 response 的处理能力

5.请求的模拟接口是否存在？

6\.**请求转发，调用模拟接口**

请求转发：使用Path匹配断言

所有前缀为：/api/ 的请求进行转发，转发到http://localhost:8123/api

比如请求网关：http://localhost:8090/api/name/?name=archer转发到 http://localhost:8123/api/name/?name=archer

7.响应日志

8.调用成功，接口调用次数+1

代码在backend项目已经写完了，用RPC调用到本项目

9.调用失败，返回规范错误码



**RPC**（Remote Procedure Call）远程过程调用

**网关业务逻辑**

问题： 网关项目比较存粹，没有操作数据库的包，并且还要调用我们之前写过的代码？复制粘贴维护麻烦

理想：直接请求到其他项目的方法

**怎么调用其他项目的方法？**

1.复制代码和依赖，环境

2.HTTP请求（提供接口，供其他项目调用）

3.RPC

4.把公共的代码打个jar包，其他项目去引用

**HTTP请求怎么调用**

1.提供方提供一个接口（地址，请求方法，参数，返回值）

2.调用方使用HTTP Client之类的代码包去发送HTTP请求

**RPC作用**

像调用本地方法一样去调用远程方法



**RPC优点**

1.对开发者更透明,减少很多的沟通成本

2.RPC向远程服务器发送请求时，未必使用HTTP协议，比如还可以使用TCP/IP，性能更高。（内部服务更实适用）



**1、Dubbo框架（RPC实现）**

两种使用方式

 	1.Spring Boot代码（注解+编程式）：写Java接口，服务提供者和消费者都去引用这个接口偏程导

 	2.IDL(接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件。优点是跨语言，所有的框架都认识



**项目整合Dubbo、Nacos**

1.backend项目作为服务提供者，提供3个方法：

 	1.实际情况应该是去数据库中查是否已分配给用户密钥（ak，sk是否合法）

 		1.先根据accessKey判断用户是否存在，查到secretKey

 		2.对比secretKey和用户传的加密后的secretkey是否一致

 	2.从数据库中查询模拟接口是否存在，以及请求方法是否匹配（还可以校验请求参数）

 	3.调用成功，接口调用次数+1invokeCount

2.gateway项日作为服务调用者，调用这3个方法

因为dubbo的zookeeper版本冲突，这边换成nacos

安装启动Nacos：sh startup.sh -m standalone

启动命令(standalone代表着单机模式运行，非集群模式)

注意：

 	1.服务接口类必须要在同一个包下，建议是抽象出一个公共项目（放接口、实体类等）

 	2.置注解（比如启动类的EnableDubbo、接口实现类和Bean引用的注解：@DubboService、@DubboReference）

 	3.添加配置

 	4.服务调用项目和提供者项目尽量引入相同的依赖和配置



**问题：如何获取接口转发服务器的地址**

网关启动时，获取所有的接口信息，维护到内存的hashmap中；有请求时，根据请求的url路径或者其他参数【比如host请求头）来判断应该转发到哪台服务器、以及用于校验接口是否存在



**公共服务模块**

目的是让方法、实体类在多个项目间复用，减少重复编写

1、抽取的服务

 	1.数据库中查是否已分配给用户秘钥(根据 accessKey 拿到用户信息，返回用户信息，为空表示不存在）

 	2.从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）

 	3.接口调用次数+ 1 invokeCount (accessKey、secretKey(标识用户），请求接口路径)

2、实现步骤：

 	1.新建干净的maven项目，只保留必要的公共依赖

 	2.抽取service和实体类

 	3. install 本地maven 包

 	4.让服务提供者引l入common包，测试是否正常运行

 	5.让服务消费者引入common包



**统计分析功能**

需求：各接口的总调用次数占比（饼图）取调用最多的前 3个接口，从而分析出哪些接口没有人用（降低资源、或者下线），高频接口（增加资源、提高收费）。用饼图展示。

1、后端

编写sql

SELECT

&nbsp;	interface\_info\_id,

&nbsp;	SUM( total\_num ) AS invoke\_num 

FROM

&nbsp;	user\_interface\_info 

GROUP BY

&nbsp;	interface\_info\_id 

ORDER BY

&nbsp;	invoke\_num DESC 

&nbsp;	LIMIT 3

2、编写接口

新增VO、Mapper、Service、Controller

VO

